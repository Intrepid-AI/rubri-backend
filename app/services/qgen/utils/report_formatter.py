"""
Report Formatting Utilities for Multi-Agent Technical Interview System
"""

from datetime import datetime
from typing import Dict, List, Any
from app.services.qgen.models.schemas import CandidateEvaluation, InterviewSection, SkillAssessment, TechnicalQuestion, ExpectedResponse
from app.logger import get_logger

# Initialize logger for report formatting
logger = get_logger(__name__)

def format_final_report(evaluation: CandidateEvaluation) -> str:
    """Format the complete evaluation into a comprehensive markdown report."""
    
    report_lines = []
    
    # Header
    report_lines.append(f"# Technical Interview Evaluation: {evaluation.candidate_name or 'Candidate'}")
    report_lines.append(f"**Position:** {evaluation.position_title}")
    report_lines.append(f"**Evaluation Date:** {evaluation.evaluation_date.strftime('%Y-%m-%d %H:%M')}")
    report_lines.append(f"**Input Scenario:** {evaluation.input_scenario.value}")
    report_lines.append("")
    
    # Executive Summary
    report_lines.append("## Executive Summary")
    report_lines.append("")
    report_lines.append(f"**Skills Identified:** {evaluation.total_skills_identified}")
    report_lines.append(f"**Categories Covered:** {len(evaluation.skill_categories)}")
    report_lines.append(f"**Technical Questions Generated:** {evaluation.total_questions}")
    report_lines.append(f"**Estimated Interview Duration:** {evaluation.estimated_interview_duration} minutes")
    report_lines.append("")
    report_lines.append(f"**Overall Recommendation:** {evaluation.overall_recommendation}")
    report_lines.append("")
    
    # Key Insights
    report_lines.append("## Key Insights")
    report_lines.append("")
    
    report_lines.append("### Strengths")
    for strength in evaluation.key_strengths:
        report_lines.append(f"- {strength}")
    report_lines.append("")
    
    if evaluation.potential_concerns:
        report_lines.append("### Areas for Assessment")
        for concern in evaluation.potential_concerns:
            report_lines.append(f"- {concern}")
        report_lines.append("")
    
    report_lines.append("### Recommended Focus Areas")
    for focus in evaluation.recommended_focus_areas:
        report_lines.append(f"- {focus}")
    report_lines.append("")
    
    # Interview Structure Overview
    report_lines.append("## Interview Structure Overview")
    report_lines.append("")
    report_lines.append("| Section | Skills Covered | Questions | Time (min) |")
    report_lines.append("|---------|----------------|-----------|------------|")
    
    for i, section in enumerate(evaluation.interview_sections, 1):
        skills_count = len(section.skill_assessments)
        questions_count = sum(len(assessment.questions) for assessment in section.skill_assessments)
        report_lines.append(f"| {i}. {section.section_name} | {skills_count} | {questions_count} | {section.estimated_total_time} |")
    
    report_lines.append("")
    
    # Detailed Technical Sections
    for i, section in enumerate(evaluation.interview_sections, 1):
        report_lines.extend(format_interview_section(section, i))
    
    # Footer
    report_lines.append("---")
    report_lines.append("*Generated by Multi-Agent Technical Interview System*")
    report_lines.append(f"*Report generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*")
    
    return "\n".join(report_lines)

def format_interview_section(section: InterviewSection, section_number: int) -> List[str]:
    """Format a single interview section."""
    
    lines = []
    
    lines.append(f"## Section {section_number}: {section.section_name}")
    lines.append(f"*{section.description}*")
    lines.append(f"**Estimated Time:** {section.estimated_total_time} minutes | **Priority:** {section.priority}/5")
    lines.append("")
    
    # Skills in this section
    for j, assessment in enumerate(section.skill_assessments, 1):
        lines.extend(format_skill_assessment(assessment, section_number, j))
    
    return lines

def format_skill_assessment(assessment: SkillAssessment, section_num: int, skill_num: int) -> List[str]:
    """Format a single skill assessment."""
    
    lines = []
    
    lines.append(f"### {section_num}.{skill_num} {assessment.skill_name}")
    lines.append("")
    
    # Skill context
    skill = assessment.extracted_skill
    lines.append(f"**Experience Level:** {skill.experience_level} (Confidence: {skill.confidence_score}/5)")
    lines.append(f"**Evidence:** {skill.evidence_from_text}")
    if skill.context:
        lines.append(f"**Context:** {skill.context}")
    if skill.specific_technologies:
        lines.append(f"**Related Technologies:** {', '.join(skill.specific_technologies)}")
    lines.append("")
    
    # Assessment summary
    lines.append(f"**Assessment Overview:** {assessment.overall_assessment}")
    lines.append("")
    
    # Questions
    lines.append("**Technical Questions:**")
    lines.append("")
    
    for k, question in enumerate(assessment.questions, 1):
        lines.extend(format_technical_question(question, section_num, skill_num, k, assessment.expected_responses))
    
    return lines

def format_technical_question(question: TechnicalQuestion, section_num: int, skill_num: int, 
                            question_num: int, expected_responses: List[ExpectedResponse]) -> List[str]:
    """Format a single technical question with its expected response."""
    
    lines = []
    question_id = f"{section_num}.{skill_num}.{question_num}"
    
    lines.append(f"**{question_id}. {question.question_text}**")
    lines.append("")
    
    # Question metadata
    lines.append(f"- **Question Type:** {question.question_type.value.replace('_', ' ').title()}")
    lines.append(f"- **Difficulty Level:** {question.difficulty_level}/5")
    lines.append(f"- **Estimated Time:** {question.estimated_time_minutes} minutes")
    lines.append(f"- **Rationale:** {question.rationale}")
    if question.tags:
        lines.append(f"- **Tags:** {', '.join(question.tags)}")
    lines.append("")
    
    # Find corresponding expected response
    expected_response = next((r for r in expected_responses if r.question_id == question.question_id), None)
    
    if expected_response:
        lines.extend(format_expected_response(expected_response))
    else:
        lines.append("*Expected response guidance not available*")
        lines.append("")
    
    return lines

def format_expected_response(response: ExpectedResponse) -> List[str]:
    """Format expected response guidance for interviewer."""
    
    lines = []
    
    lines.append("**Interviewer Guidance:**")
    lines.append("")
    
    # Key concepts
    lines.append("*Key Concepts Required:*")
    for concept in response.key_concepts_required:
        lines.append(f"  - {concept}")
    lines.append("")
    
    # Good answer indicators
    lines.append("*Good Answer Indicators:*")
    for indicator in response.good_answer_indicators:
        lines.append(f"  - {indicator}")
    lines.append("")
    
    # Red flags
    lines.append("*Red Flags:*")
    for flag in response.red_flags:
        lines.append(f"  - {flag}")
    lines.append("")
    
    # Follow-up questions
    lines.append("*Suggested Follow-up Questions:*")
    for follow_up in response.follow_up_questions:
        lines.append(f"  - {follow_up}")
    lines.append("")
    
    # Scoring rubric
    lines.append("*Scoring Rubric:*")
    for level, criteria in response.scoring_rubric.model_dump().items():
        clean_level = level.replace('_', ' ').title()
        lines.append(f"  - **{clean_level}:** {criteria}")
    lines.append("")
    
    return lines

def format_json_report(evaluation: CandidateEvaluation) -> Dict[str, Any]:
    """Format evaluation as structured JSON data."""
    
    return {
        "candidate_info": {
            "name": evaluation.candidate_name,
            "position": evaluation.position_title,
            "evaluation_date": evaluation.evaluation_date.isoformat(),
            "input_scenario": evaluation.input_scenario.value
        },
        "summary": {
            "skills_identified": evaluation.total_skills_identified,
            "categories_covered": len(evaluation.skill_categories),
            "questions_generated": evaluation.total_questions,
            "estimated_duration_minutes": evaluation.estimated_interview_duration,
            "overall_recommendation": evaluation.overall_recommendation
        },
        "insights": {
            "key_strengths": evaluation.key_strengths,
            "potential_concerns": evaluation.potential_concerns,
            "recommended_focus_areas": evaluation.recommended_focus_areas
        },
        "skill_categories": [
            {
                "name": cat.name,
                "description": cat.description,
                "priority": cat.priority
            }
            for cat in evaluation.skill_categories
        ],
        "interview_sections": [
            {
                "section_id": section.section_id,
                "section_name": section.section_name,
                "description": section.description,
                "estimated_time_minutes": section.estimated_total_time,
                "priority": section.priority,
                "skills": [
                    {
                        "skill_name": assessment.skill_name,
                        "category": assessment.category,
                        "experience_level": assessment.extracted_skill.experience_level,
                        "confidence_score": assessment.extracted_skill.confidence_score,
                        "evidence": assessment.extracted_skill.evidence_from_text,
                        "context": assessment.extracted_skill.context,
                        "questions": [
                            {
                                "question_id": q.question_id,
                                "question_text": q.question_text,
                                "question_type": q.question_type.value,
                                "difficulty_level": q.difficulty_level,
                                "estimated_time_minutes": q.estimated_time_minutes,
                                "rationale": q.rationale,
                                "tags": q.tags
                            }
                            for q in assessment.questions
                        ],
                        "expected_responses": [
                            {
                                "question_id": er.question_id,
                                "key_concepts_required": er.key_concepts_required,
                                "good_answer_indicators": er.good_answer_indicators,
                                "red_flags": er.red_flags,
                                "follow_up_questions": er.follow_up_questions,
                                "scoring_rubric": er.scoring_rubric.model_dump()
                            }
                            for er in assessment.expected_responses
                        ]
                    }
                    for assessment in section.skill_assessments
                ]
            }
            for section in evaluation.interview_sections
        ]
    }

def format_summary_report(evaluation: CandidateEvaluation) -> str:
    """Format a concise summary report."""
    
    lines = []
    
    lines.append(f"# Interview Summary: {evaluation.candidate_name or 'Candidate'}")
    lines.append(f"**Position:** {evaluation.position_title}")
    lines.append("")
    
    lines.append("## Quick Stats")
    lines.append(f"- **Skills Identified:** {evaluation.total_skills_identified}")
    lines.append(f"- **Questions Generated:** {evaluation.total_questions}")
    lines.append(f"- **Interview Duration:** {evaluation.estimated_interview_duration} minutes")
    lines.append("")
    
    lines.append("## Recommendation")
    lines.append(evaluation.overall_recommendation)
    lines.append("")
    
    lines.append("## Key Strengths")
    for strength in evaluation.key_strengths:
        lines.append(f"- {strength}")
    lines.append("")
    
    if evaluation.potential_concerns:
        lines.append("## Areas to Assess")
        for concern in evaluation.potential_concerns:
            lines.append(f"- {concern}")
        lines.append("")
    
    lines.append("## Focus Areas")
    for focus in evaluation.recommended_focus_areas:
        lines.append(f"- {focus}")
    
    return "\n".join(lines)

def export_questions_only(evaluation: CandidateEvaluation) -> str:
    """Export just the questions in a clean format for interviewers."""
    
    lines = []
    
    lines.append(f"# Technical Interview Questions: {evaluation.candidate_name or 'Candidate'}")
    lines.append(f"**Position:** {evaluation.position_title}")
    lines.append(f"**Total Questions:** {evaluation.total_questions} | **Duration:** {evaluation.estimated_interview_duration} minutes")
    lines.append("")
    
    for i, section in enumerate(evaluation.interview_sections, 1):
        lines.append(f"## {i}. {section.section_name}")
        lines.append("")
        
        for j, assessment in enumerate(section.skill_assessments, 1):
            lines.append(f"### {i}.{j} {assessment.skill_name} Questions")
            lines.append("")
            
            for k, question in enumerate(assessment.questions, 1):
                question_num = f"{i}.{j}.{k}"
                lines.append(f"**Q{question_num}: {question.question_text}**")
                lines.append(f"*Time: {question.estimated_time_minutes} min | Difficulty: {question.difficulty_level}/5*")
                lines.append("")
    
    return "\n".join(lines)

# Utility functions for different export formats
def save_report(evaluation: CandidateEvaluation, filename: str, format_type: str = "markdown"):
    """Save report to file in specified format."""
    
    if format_type == "markdown":
        content = format_final_report(evaluation)
    elif format_type == "json":
        import json
        content = json.dumps(format_json_report(evaluation), indent=2)
    elif format_type == "summary":
        content = format_summary_report(evaluation)
    elif format_type == "questions":
        content = export_questions_only(evaluation)
    else:
        raise ValueError(f"Unsupported format: {format_type}")
    
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(content)
    
    return filename

def generate_filename(evaluation: CandidateEvaluation, format_type: str = "markdown") -> str:
    """Generate appropriate filename for the report."""
    
    candidate_name = (evaluation.candidate_name or "candidate").replace(" ", "_").lower()
    position = evaluation.position_title.replace(" ", "_").lower()
    date = evaluation.evaluation_date.strftime("%Y%m%d")
    
    extension = {
        "markdown": "md",
        "json": "json", 
        "summary": "md",
        "questions": "md"
    }.get(format_type, "txt")
    
    return f"{candidate_name}_{position}_{date}_interview_evaluation.{extension}"